# TEXTO üìÑ

We see three critical differences between programming and software engineering: time, scale, and the trade-offs at play. On a software engineering project, engineers need to be more concerned with the passage of time and the eventual need for change. In a software engineering organization, we need to be more concerned about scale and efficiency, both for the software we produce as well as for the organization that is producing it. Finally, as software engineers, we are asked to make more complex decisions with higher-stakes outcomes, often based on imprecise estimates of time and growth.


## COMENTARIO üí¨

O texto mostra que h√° diferen√ßas entre a programa√ß√£o e engenharia de software. Na engenharia de software, os engenheiros s√£o focados no tempo e nas mudan√ßas necess√°rias no projeto. Na engenharia de software, √© necessario priorizar a escala e efici√™ncia para produzir, e tamb√©m tomar decis√µes importantes e complexas, geralmente baseadas no tempo e tamanho.


# TEXTO 2 üìÑ

Within Google, we sometimes say, ‚ÄúSoftware engineering is programming integrated over time.‚Äù Programming is certainly a significant part of software engineering: after all, programming is how you generate new software in the first place. If you accept this distinction, it also becomes clear that we might need to delineate between programming tasks (development) and software engineering tasks (development, modification, maintenance). The addition of time adds an important new dimension to programming. Cubes aren‚Äôt squares, distance isn‚Äôt velocity. Software engineering isn‚Äôt programming.

# COMENTARIO üí¨

O texto mostra que com o Google, as vezes dizemos que a engenharia de software √© a programa√ß√£o integrada com o tempo. A programa√ß√£o √© uma parte significante da engenharia de software, depois de tudo, a programac√£o √© como voc√™ cria um novo software, em primeiro lugar. Se voc√™ aceita essa distin√ß√£o, fica mais claro que precisamos delinear entre tarefas de programa√ß√£o (desenvolvimento) e tarefas da engenharia de software (desenvolvimento, modifica√ß√£o, manuten√ß√£o). A implementa√ß√£o de tempo adiciona uma importante nova dimen√ß√£o para programa√ß√£o. Cubos n√£o s√£o quadrados, distancia n√£o √© velocidade. Engenharia de software n√£o √© programa√ß√£o.


## Exemplos de Trade-Offs
  1. Ao planejar o desenvolvimento de um aplicativo, desenvolver em uma tecnologia como flutter, resultar√° numa aplica√ß√£o para ambos os sistemas IOS e Android, por√©m nos dois pode apresentar problemas, diferente de uma tecnologia voltada a um s√≥ sistema, como o Kotlin (Android).
  2. Utilizar sistemas mais simples para desenvolver, pode acarretar num problema de quantidade de usuarios ao mesmo tempo na aplicacao.
  3. O sistema operacional Linux √© mais completo e personalizavel, por√©m sua complexidade para utilizar, afasta sua popularidade para leigos em tecnologia.

## Exemplo de sistemas que se sobressaem por requisitos

O sistema operacional para dispositivos moveis IOS se sobressai em rela√ß√£o ao Android, pois seus requisitos funcionam melhor. Diferente do Android, que foi desenvolvido majoritariamente em Java e √© open source, o IOS foi planejado e desenvolvido de forma precisa, com diversas criptografias e funcionalidades exclusivas, tornando assim mais veloz, acessivei e seguro.
